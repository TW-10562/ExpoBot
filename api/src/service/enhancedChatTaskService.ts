/**
 * Enhanced Chat Task Processor
 * 
 * CRITICAL ORCHESTRATION:
 * 1. Language Detection → Query Classification → Department Triage
 * 2. Document Access Control → RAG Search (department-scoped only)
 * 3. Answer Generation → Source Attribution → Audit Logging
 * 4. FAQ Analytics Tracking → User Feedback Processing
 * 5. Escalation Handling
 * 
 * Security:
 * - NO document leakage across departments
 * - ALL operations audited
 * - Sources validated and attributed
 * - Department filtering BEFORE RAG
 */

import { classifyQuery } from '@/service/triageAgentService';
import { getAccessibleDocumentsForDepartment } from '@/service/departmentAccessService';
import { attachSourceAttribution, extractDocumentIdsFromRAG } from '@/service/sourceAttributionService';
import { trackQueryForAnalytics, getFAQRecommendations } from '@/service/faqAnalyticsService';
import { logQueryClassification, logRAGRetrieval, logAnswerGeneration, logFailedOperation } from '@/service/auditService';
import { translateContent } from '@/service/translate';

export interface IEnhancedChatTaskInput {
  taskId: string;
  userId: bigint;
  query: string;
  ipAddress?: string;
  userAgent?: string;
}

export interface IEnhancedChatTaskOutput {
  taskId: string;
  originalQuery: string;
  detectedLanguage: 'en' | 'ja';
  classifiedDepartment: 'HR' | 'GA' | 'OTHER';
  classificationConfidence: number;
  ragTriggered: boolean;
  sourceDocumentIds: number[];
  answer: string;
  sourceAttribution: string;
  faqRecommendations: any[];
  escalationUrl?: string;
}

/**
 * Main chat task orchestration
 * This is the heart of the system - all features are coordinated here
 */
export async function processChatTask(
  input: IEnhancedChatTaskInput
): Promise<IEnhancedChatTaskOutput> {
  const startTime = Date.now();
  
  try {
    // STEP 1: CLASSIFY QUERY & LANGUAGE DETECTION
    // ==================================================
    console.log(`[${input.taskId}] Processing query:`, input.query.substring(0, 50));
    
    const classification = await classifyQuery(input.query);
    
    // Log classification
    await logQueryClassification(
      input.userId,
      input.taskId,
      input.query,
      classification.department,
      classification.confidence,
      classification.language,
      classification.detectedKeywords,
      input.ipAddress,
      input.userAgent
    );

    console.log(`[${input.taskId}] Classified as ${classification.department} (${classification.confidence}%)`);

    // STEP 2: GET DEPARTMENT-SCOPED DOCUMENT ACCESS
    // ==================================================
    const accessibleDocumentIds = await getAccessibleDocumentsForDepartment(
      classification.department
    );

    console.log(`[${input.taskId}] Accessible documents for ${classification.department}: ${accessibleDocumentIds.length}`);

    // STEP 3: CALL RAG WITH DEPARTMENT-SCOPED DOCUMENTS
    // ==================================================
    // NOTE: RAG call would be made here with accessibleDocumentIds filter
    // This example assumes you call the RAG service with a department_scope parameter
    let ragResponse: any = null;
    let sourceDocumentIds: number[] = [];
    let ragTriggered = false;

    // Placeholder for actual RAG call - would integrate with existing RAG service
    // const ragResponse = await callRAGService({
    //   query: classification.language === 'ja' ? input.query : translateToJapanese(input.query),
    //   department: classification.department,
    //   document_ids: accessibleDocumentIds,
    //   language: classification.language,
    // });

    if (ragResponse && ragResponse.results && ragResponse.results.length > 0) {
      ragTriggered = true;
      sourceDocumentIds = extractDocumentIdsFromRAG(ragResponse);

      // Validate sources are in accessible documents
      sourceDocumentIds = sourceDocumentIds.filter(id => 
        accessibleDocumentIds.includes(id)
      );

      // Log RAG retrieval
      await logRAGRetrieval(
        input.userId,
        input.taskId,
        1, // TODO: Get actual department_id
        sourceDocumentIds,
        input.ipAddress,
        input.userAgent
      );

      console.log(`[${input.taskId}] RAG triggered, ${sourceDocumentIds.length} documents retrieved`);
    }

    // STEP 4: GENERATE ANSWER
    // ==================================================
    // Placeholder for actual LLM call
    // const answer = await callLLM({
    //   query: input.query,
    //   context: ragResponse ? ragResponse.results : [],
    //   language: classification.language,
    //   fallback: getSafeFallbackResponse(classification.department),
    // });

    let answer = 'Sample answer that would be generated by the LLM based on RAG results.';
    
    if (!ragTriggered || sourceDocumentIds.length === 0) {
      // No documents found - return safe fallback
      answer = getSafeFallbackResponse(classification.department);
    }

    // Log answer generation
    await logAnswerGeneration(
      input.userId,
      input.taskId,
      1, // TODO: Get actual department_id
      classification.language,
      sourceDocumentIds,
      input.ipAddress,
      input.userAgent
    );

    // STEP 5: ATTACH SOURCE ATTRIBUTION
    // ==================================================
    const attributed = await attachSourceAttribution(
      answer,
      sourceDocumentIds,
      input.userId,
      1 // TODO: Get actual department_id
    );

    // STEP 6: TRACK FOR FAQ ANALYTICS
    // ==================================================
    await trackQueryForAnalytics(
      1, // TODO: Get actual department_id
      input.query,
      classification.language,
      sourceDocumentIds.length > 0 ? sourceDocumentIds[0] : undefined,
      75 // Default quality score until feedback
    );

    // STEP 7: GET FAQ RECOMMENDATIONS
    // ==================================================
    const faqRecommendations = await getFAQRecommendations(
      1, // TODO: Get actual department_id
      input.query,
      3
    );

    console.log(`[${input.taskId}] Completed in ${Date.now() - startTime}ms`);

    return {
      taskId: input.taskId,
      originalQuery: input.query,
      detectedLanguage: classification.language,
      classifiedDepartment: classification.department,
      classificationConfidence: classification.confidence,
      ragTriggered,
      sourceDocumentIds,
      answer: attributed.answer,
      sourceAttribution: attributed.source_text,
      faqRecommendations,
    };
  } catch (error) {
    console.error(`[${input.taskId}] Error processing chat task:`, error);
    
    // Log failed operation
    await logFailedOperation(
      input.userId,
      'CHAT_TASK_PROCESSING',
      'TASK',
      'Failed to process chat query',
      error,
      input.ipAddress,
      input.userAgent
    );

    throw error;
  }
}

/**
 * Get safe fallback response when no documents match the query
 */
function getSafeFallbackResponse(department: 'HR' | 'GA' | 'OTHER'): string {
  const fallbacks: Record<string, string> = {
    HR: 'I apologize, but I could not find relevant HR policy documents to answer your question. ' +
        'Please contact the HR department directly for assistance with your inquiry.',
    GA: 'I apologize, but I could not find relevant General Affairs documentation. ' +
        'Please contact the General Affairs department or facility management for help.',
    OTHER: 'I apologize, but I could not find relevant information to answer your question. ' +
           'Please reach out to the appropriate department for support.',
  };

  return fallbacks[department] || fallbacks.OTHER;
}

/**
 * Process escalation request
 * Called when user indicates dissatisfaction with answer
 */
export async function handleEscalationRequest(
  taskId: string,
  userId: bigint,
  query: string,
  answer: string,
  sourceDocumentIds: number[],
  department: 'HR' | 'GA' | 'OTHER',
  reason?: string,
  ipAddress?: string,
  userAgent?: string
): Promise<{ ticketNumber: string; escalationUrl: string }> {
  const { createEscalationTicket } = await import('@/service/escalationService');

  const escalation = await createEscalationTicket({
    user_id: userId,
    original_query: query,
    bot_answer: answer,
    source_documents: sourceDocumentIds.map(id => ({ id })),
    department,
    reason: reason || 'User initiated escalation',
    ipAddress,
    userAgent,
  });

  if (!escalation) {
    throw new Error('Failed to create escalation ticket');
  }

  return {
    ticketNumber: escalation.ticket_number,
    escalationUrl: `/escalation/${escalation.ticket_number}`,
  };
}

/**
 * Process user feedback on answer quality
 * Updates FAQ analytics
 */
export async function processFeedback(
  taskId: string,
  query: string,
  rating: number, // 1-5 scale
  departmentId: number
): Promise<void> {
  const { updateAnswerQualityScore } = await import('@/service/faqAnalyticsService');
  
  // Convert 1-5 rating to 0-100 quality score
  const qualityScore = (rating / 5) * 100;
  
  await updateAnswerQualityScore(departmentId, query, qualityScore);
  
  console.log(`[${taskId}] Feedback recorded: ${rating}/5 stars (${qualityScore} quality score)`);
}
